面试问题1：
#ifndef  #define #endif 防止头文件重复包含
const 在堆栈分配内存 有数据类型，，，宏常量没有数据类型；const定义常量，修饰函数形参(输入参数为抽象数据类型)，修饰函数返回值。
static：函数体内，在函数被调用过程保持不变；模块内，可被模块内函数访问，不能被模块外访问。
static全局变量只初始化一次，下次依据上次结果，防止其他文件单元引用。

sizeof 操作符(结果返回size_t) 在编译的时候计算过； strlen 函数 结尾必须是“\0”  在运行时才计算
内联函数代替c语言中的宏定义，来解决程序中函数调用效率问题。使用时直接使用，无调用开销，效率提高，可当成成员函数，。内联以代码复制为代价，函数体较长 不适合使用。
内联在编译时候展开，宏定义在预编译展开，宏不是函数，内联是函数，宏容易出现二义性。

指针和引用区别：指针是c语言中使用的一种广泛数据类型；引用是c++新引入的语言特性。
初始化不同：引用必需初始化，指针不一定；可修改性：引用一旦初始化不能改变，指针可以改变；不存在NULL引用，指针存在；测试不同，引用不存在NULL，不同测试，指针需要测试。
引用既有指针的效率，又具有变量使用的方便和直观性。

整型数：int a;
指向整型的指针：int *a；
指向指针的指针，指向的指针指向一个整型数：int **a;
一个十个整型数的数组：int a[10];
一个10个指针的数组，该指针指向一个整型数：int *a[10];
一个指向有10个整型数数组的指针：int (*a)[10]
一个指向函数的指针，该函数有一个整型参数并返回一个整型：int (*a)(int);
一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型：int(*a[10])(int);  //右左法则
指针数组：int *a[10];    表示一个数组，数组里存放每个元素指针
数组指针：int (*a)[10]   表示一个指针，指向数据
指针函数：int *a();       本质是函数，返回类型是某一类型指针
函数指针：int (*a)(int);  本身是指针，只不过该指针直线管理函数
指针常量：int * const a;
常量指针：const int* a;

char str1[] = "sad";char str2[]="sad"; str1!=str2如果是char *str1和char*str2则两个相等。

char *const p1 指针常量  内容可改
char const *p 常量指针 内容不可改
const char *p 常量指针 内容不可改
const char*const p4 都不可以改

this指针非静态成员函数才有

野指针：指向垃圾的指针 ，不是NULL指针，；指针变量违背初始化，指针被释放后未置空所带来的。

new/delete和malloc/free区别：前者是运算符，后者是函数，对于非内部数据类型对象，对象在消亡前自动执行析构，后者是运算符 不在编译器控制范围，不能将构造和析构强行加入

动态内存传递：

内存分配：静态存储区域分配-全局变量；栈上创建-函数局部变量；堆分配(动态分配)-new  等

Windows编程句柄：实例、位、设备、图标等  通用句柄HANDLE  ；句柄地址-记载对象的内存地址-对象内存地址-实际对象

strcpy和memcpy：复制内容不同；复制方法不同；用途不同

面向对象：类：具有相似内部状态和运动规律的实体集合；对象：现实世界各种实体，类的实例；消息：对象相互联系，相互作用的方式；类特性：抽象、继承、封装、重载、多态。

调用构造函数：构造函数带参数时声明对象后面加上(),不带参数时，不用加。类成员初始化，先定义先初始化，初始化顺序和变量声明顺序一致。

静态成员是私有，不会出现全局名称冲突；const和reference类型成员变量只能初始化不能赋值。

虚析构函数：实现多态，作用是防止内存泄漏。不能正常调用析构函数

复制构造函数  A(A &test){ a=test.a}   A(const char*str){buf = new char[strlen(str)+1];strcpy(buf,str)}

c++继承：public，保存父类的可见性，如果父类是public 则子类继承后也是；    protected，强制将父类public修改成protected，这样子类可以调用父类的public和protected； private，将父类修改成private 则子类的子类就无法访问父类的public或者protected；
父类的private 子类如果继承 都不能被访问。  如果是protected 只能在类内访问。

多态：编译时多态-重载    运行时多态-虚函数(通过虚函数表实现)

排序：插入、选择、交换、归并、分配

重载和重写、隐藏区别：重写是覆盖，指在派生类中重新定义基类的函数，其函数名、参数列表和返回值与基类中被重写函数一致，只有函数体不同，基类被重写的函数必需要virtual修饰。
                                   重载指同一访问区内被声明的几个具有不同参数列(参数类型、个数和顺序不同)的同名函数，根据参数列表确定调用那个函数，重载不关心函数返回类型。
                                   隐藏是指派生类的函数屏蔽了与其同名的基类函数，只有同名函数，不管参数列表是否相同。

内存地址计算方式：从40000H到BBFFFH共有多少KB。
BBFFFH-40000H=7BFFFH。转换成二进制：7BFFFH=01111011111111111111B=(2^19-1-2^14)/2^10KB。约等于496KB。  1KB=2^3*1B = 2^3*2^7 = 2^10(1B=八位二进制) ；







c和c++区别：c不具备布尔类型，c是结构化语言，重点在于算法和结构，c是c++子集，c实现了c++中过程化控制及其他功能。c++相对于原来的c有加强，引入重载，内联等操作。面向对象的虚函数等。

tcp/ip和UDP机制和区别：面向连接和面向无连接、传输稳定和不稳定，数据丢失。五层协议：物理层、数据链路层、网络层、传输层、应用层、

windows：消息传递、信号和映射：

virtual在构造函数和析构函数应用：



vector、list、map、queue、tree、graph之间的应用和区别：
 1.vector  底层数据结构为数组 ，支持快速随机访问
2.list    底层数据结构为双向链表，支持快速增删
3.deque   底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问
4.stack   底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
5.queue   底层一般用23实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
6.45是适配器,而不叫容器，因为是对容器的再封装
7.priority_queue 的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现
8.set       底层数据结构为红黑树，有序，不重复
9.multiset  底层数据结构为红黑树，有序，可重复 
10.map      ﻿﻿﻿﻿底层数据结构为红黑树，有序，不重复
11.multimap 底层数据结构为红黑树，有序，可重复
12.hash_set ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复
13.hash_multiset 底层数据结构为hash表，无序，可重复 
14.hash_map      ﻿﻿﻿﻿底层数据结构为hash表，无序，不重复
15.hash_multimap 底层数据结构为hash表，无序，可重复  
vector表示一段连续的内存区域，随机访问效率很高，因为每次访问离起始处的位移都是固定的，但是在随意位置插入删除元素效率很低，因为它需要将后面的元素复制一遍。 
list表示非连续的内存区域，并通过一对指向首尾元素的指针双向链接起来，从而允许向前和向后两个方向进行遍历。
在list的任意位置插入和删除元素的效率都很高：指针必须被重新赋值，但不需要用拷贝元素来实现移动。他对随机访问支持不好，需要遍历中间的元素。
每个元素有两个指针的额外空间开销。 deque（双端队列，发音为'deck'）也表示一段连续的内存区域，但是他支持高效的在其首部插入和删除元素。





堆是不连续的，生长方向是向上的，即向着内存地址增大的方向增长；栈是连续的，生长方向是向下的，即向着内存地址减小的方向增长。 

看程序找错误：
多进程和多线程：
多态、继承、封装：



.c文件编译成.o文件 然后链接执行生成.exe文件
继承输出问题：

面试问题2：
区别：
putchar 
getchar
puts 
gets

代码块之外声明的属于静态变量，实参在堆栈中传递给函数，实现递归。
static：在代码块内在程序运行之前创建，在程序整个执行过程存在，始终保持原先值除非赋予一个新值或者程序结束；在代码块外部修改标识符属性，external-》internal。
extren
register 变量频繁使用 在寄存器中。自动变量声明，比存储于内存的变量访问起来效率更高，如果声明太多，只取前几个
volition防止编译器对代码优化



#include<a>
#incldue “a”
：两者区别不大，前者是系统库函数头文件或者标准头文件(先重预定义目录尽心查找)，后者是本工程文件(用户提供的头文件，从当前目录查找)，后者在当前目录下进行查找，如果未查到，则在标准位置进行查找。

数组名作为实参时，传给函数的实际是一个指向数组起始位置的指针-数组以地址传递

sizeof()运算符  空类大小为1；加入构造函数和析构函数  只是知道地址就可以。如果析构函数式虚函数，就会生成虚函数表，添加一个虚函数指针，在32位机器占4个字节，64位占8个字节。 

数组、字符串、链表、树、栈、队列
数组：占据一块连续的内存并按照顺序存储数据，创建数组时，需要首先指定数组容量大小，然后根据大小分配内存，内存是连续的。当函数参数声明为数组时，就会退化成指针。

栈和递归    队列和广度优先遍历

