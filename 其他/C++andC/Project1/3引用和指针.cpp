#include <iostream>
#include <cstdio>
using namespace std;

//宏定义  最大值
#define Max1(x,y) (((x)>(y))?(x):(y))

//引用是c++引入的高级特性 。指针是c语言中广泛使用的一种数据类型
//引用变量必需初始化

//交换两个  引用-指针-异或 -自加

//指针和引用：初始化要求--引用创建时就需要初始化；可修改性--引用一旦初始化指向一个对象，就不能被改成另一个对象引用；
//不存在NULL引用引用不存在空引用，必需指向某个对象；测试区别--使用引用前不必测试，不存在空引用，指针需要进行测试；应用区别--一旦指向就不改变，则使用引用
//引用既有指针的效率，又具有变量使用的方便性和直观性。

//引用比指针安全--不存在空引用，一旦指向对象就不会被改变，安全。指针可以随意指向其他对象，且可以不初始化，所以不安全，而且存在野指针。

//指针常量和常量指针：常量指针是指向常量的指针，，内容不可变。指针常量是指针的常量，，地址不可改

//char * const p1;//指针常量--指向的内容可以修改
//char const * p2;//常量指针--指针指向常量  内容不可修改
//const char * p3;//常量指针--指针指向常量 内容不可以修改
//const char *const p4;//都不可修改

//指针数组和数组指针：指针数组--本身是数组，内部存放同一类型的指针，在栈中分配空间；数组指针--本身是指针，指向一维或多维的数值的指针 int *b = new int[10];

//函数指针和指针函数：函数指针-本身是指针，指向函数的指针变量；指针函数--本身是函数，带指针的函数，返回类型是某一类型的指针。

//typedef作用：可以用其定义函数指针来调用相同类型的函数。

//野指针：不是空指针，指向垃圾内存的指针。主要是指针变量没有被初始化，或者被释放之后没有置成NULL。----野指针可能导致程序崩溃

//malloc/free和new/delete区别：前者是函数，后者是运算符。前者无法满足动态对象的要求，不能将构造和析构函数强行加入到其中  (类型*)malloc(size)

//c++中的new/delete可以调用构造函数和析构函数

//动态内存传递
void getMe(char*p, int num) {//错误
	p = (char*)malloc(sizeof(char)*num);
}

void getMe1(char **p, int num) {
	*p = (char*)malloc(sizeof(char)*num);//正确
}

void getMe2(char* &p, int num) {
	p = (char*)malloc(sizeof(char)*num);//正确
}

char *getMe3(int num) {
	char* p = (char*)malloc(sizeof(char)*num);
	return p;
}

//内存分配几种方式
//1.静态存储区域分配。内存在程序编译的时候分配好，例如全局变量。
//2.在栈上创建。执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。
//3.从堆上分配，动态内存分配。动态内存的生存周期由我们决定，使用非常灵活，单问题也多。 new/delete   malloc/free


//指针和句柄区别：句柄是一种指向指针的指针--指向一个复杂的结构，并且可能与系统有关。指针也可以指向一个复杂的结构，通常由用户自己定义，因此必需工作需要用户自己完成


int main3() {
	//
	//char *str = NULL;
	//getMe(str, 10);//没有做任何事情 而且会出现内存泄漏
	//strcpy(str, "hello");
	char*str1 = NULL;
	getMe1(&str1, 20);
	char*str2 = NULL;
	getMe2(str2, 20);
	char*str3 = NULL;
	str3 = getMe3(20);


	system("pause");
	return 0;
}