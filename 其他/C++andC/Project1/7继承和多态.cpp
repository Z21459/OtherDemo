#include <iostream>
#include <cstdio>
#include <vector>
#include <queue>
#include <stack>

using namespace std;
//继承和多态是面向对象的关键  多态是建立在继承之上  动态绑定-核心是父类调用子类对象的方法
//三种继承关系 public(子类代替父类中所有声明行为) private(子类不能代替完成父类所有声明，子类的子类不能调用父类) protected(子类不能代替完成父类所有声明) 
//三种继承方式的public 子类的子类可以完全访问父类的public
			//  proctected 子类的子类可以访问父类的public(将父类中的public改成proctected)
		// private 子类的子类不能访问父类的任何东西(将父类的所有改成private)

//组合和私有继承：私有继承获得基类的一份拷贝，同时获得访问基类的公共以及保护接口的权利和重写基类虚函数的能力。如果组合需要使用对象方法，则使用继承。


//多态  封装  继承 面向对象三大特征
//多态：同一操作作用不同对象，可以有不同解释，产生不同执行结果。编译时多态(根据不同参数返回值决定何种操作)--重载；
																//运行时多态(直到系统运行时，根据实际情况决定何种操作)--虚函数。

//虚函数：通过虚函数表实现的。如果一个类有虚函数，则系统会为这个类分配一个指针成员指向一张虚表，表中每一项指向一个虚函数地址，实际是函数指针数组

//构造函数中调用，虚拟机制不会发生作用

//多重继承：一些事物往往拥有两个以上属性，解决这个问题，多重继承。优点：对象可以调用多个基类中的接口，容易出现二义性。
//多重继承的构造函数顺序1.任何虚拟基类的构造函数按照他们被继承的顺序构造2.非虚拟基类的构造函数按照他们被构造的顺序构造
						//3.任何成员对象的构造按照他们的声明的顺序调用4.类自身构造函数

//抽象基类和纯虚函数：纯虚函数在基类中没有定义，必需在子类中实现。如果基类含有一个或多个纯虚函数，那就属于抽象基类，不能被实例化。。。。方便使用多态
//抽象基类 A *a; B b;a = &b;//抽象基类的使用A是抽象基类，B是继承的子类

//虚函数和纯虚函数：纯虚函数只是接口，必须在子类实现，虚函数在基类中实现(就算空实现)；虚函数可以不在子类重载，纯虚函数必需子类实现；带纯虚函数叫虚基类




int main7() {


	system("pause");
	return 0;
}