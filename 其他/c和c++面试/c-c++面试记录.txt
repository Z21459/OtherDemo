1.2 c++可以通过域操作符：：控制全局变量，c不支持局部变量和全局变量同名
1.3 ++i:先+后i；i++:先i后++；自定义数据类型时 ++i效率更高
1.7 不用中间变量交换两个数：1.异或；2.自加减
1.8 c是c++的子集：c是面向过程的语言(主要利用算法和数据结构)-结构化语言，c++是面向对象(设计的时候要考虑对象)；c实现了c++中过程化控制和其他功能，c在c++中加强了，引入重载、内联等
	             c++还需要考虑对象接口设计和继承等问题，更加丰富。 c++不完全面向对象，在c++中也可以写出和c一样的过程化程序。
1.10 头文件“ ”和<>的区别：<>表示一个工程或者标准头文件，先检查预定义目录；“”表示用户提供的头文件，从当前文件目录中寻找。

2.1#define  宏定义：#define MAX（x,y）(((x)>(y))?(x):(y)) 宏定义只是文本替换，如果不加括号，容易引起歧义。
2.8 const和#define区别：#define只能用来文本替换，无数据类型。const存在于程序数据段，并在堆栈分配空间，有数据类型。
2.9 const 定义常量-数据静态类型安全检测；修饰函数参数-提高效率；修饰返回值或者成员函数。
2.10 static：函数体-声明成静态的函数调用过程维持其值不变；模块内(函数体外)-被模块内所有函数访问；模块内-声明为静态函数，只能被模块内的其他函数调用。
2.11 非静态成员变量作用于整个程序，静态全局变量限制作用域，只在定义该变量源文件有效，避免在其他原文件中引起错误。静态变量只初始化一次，而普通函数每次都被拷贝一份。
2.17 sizeof操作符 strlen函数；sizeof用类型做参数 编译时候就被计算过，strlen必需以‘\0’结尾，运行时才被计算，计算字符串长度不同。
2.20 使用#pragma pack(1)  更改对其方式 使用其计算联合体，结构体等sizeof的大小，按照几个字节对齐
2.22 inline内联函数: 用其代替c语言中表达式宏定义来解决程序中函数调用效率问题。定义类的内联函数，在使用函数代码的时候直接尽心个替换，没有调用开销。其是一个真正函数，编译器对其进行检查。
	内联可以完全取代宏定义，当函数体在类型自动为内联，当函数体在类外，要加上inline.  内联以代码复制为代价，省去调用开销，执行时间久就没必要，而且内联复制代码，消耗内存空间。
2.26 内联和宏区别：inline在编译时候展开，#define在预编译展开；inline直接嵌套在目标代码，#define是文本替换；宏不是函数，inline是函数；宏定义容易出现二义性。


3.1引用是c++引入的，指针是c语言中广泛应用的 引用只能在声明时赋值，以后不能吧该引用名作为其他变量名，指针需要初始化，不然会变成野指针
3.4函数参数为指针引用的时候，传入函数的是实参，而不是形参；如果不是指针引用，指针交换只在函数中有效，因为在函数体内，函数栈会分配两个空间
3.7 初始化要求不同-引用创建必需初始化，指针不需要；可修改性-引用已经初始化不能修改，指针可以；不存在NULL引用；测试需求不同-引用不会指向空值，不需要测试，指针可能指向空，需要测试；
      应用的区别-若指向一个对象后不变则使用引用。引用既有指针的效率又有其的方便
3.8 传引用比指针安全，引用一旦绑定不会修改，指针能够随便指向。
3.9  ---从右向左法则
一个整数 int a；一个指向整数的指针 int* a；一个指向指针的指针，它指向的指针是指向一个整数 int** a；
一个有十个整型的数组 int a[10];一个有十个指针的数组，该指针是指向一个整型数的 int* a[10]; 一个指向有10个整型数数组指针 int (*a)[10]
一个指向函数的指针，该函数有一个整型参数并返回一个整型数 int (*a)(int)
一个有10个指针的数组，该指针指向一个函数，该函数有一个参数并返回一个整型 int (*a[10])(int);
3.11 int a[3] =[1,2,3]  a是数组首地址，相当于a[0]地址，&a相当于对象首地址，&a+1是下一个对象的地址，即a[3]
3.12 int a[2]和int b[2] 相等；char *a和char *b不相等。  不能进行隐式转换的会存在编译错误，运行错误主要是存在NULL访问违规。
3.15 指针常量 首先是一个常量，不能修改这个指针所指的地址；常量指针 首先是一个指针，内容不可变；-----------谁在前谁不能变
3.18 this指针 类的非静态成员函数才有
3.19 指针数组 是一个数组，数组中每个元素是指针；数组指针，值指针，指向这个数组。
        指针函数 是函数，带指针的函数，返回为某一类型指针；  函数指针  是一个指针 指向这个函数     ；
3.28 野指针：不是NULL指针，指向垃圾内存的指针，主要有，指针变量未初始化，或者delete之后未置空，导致程序崩溃。
3.30 malloc/free和new/delete区别：前者是函数，后者是运算符。非内部数据类型的对象，对象消亡前要进行析构，前者不是运算符，不在编译器控制范围内。  new分配堆内存
3.23-3.35动态内存分配----编译器为函数的每个参数制作临时变量
3.37 内存分配   1.静态存储区-全局变量，程序编译时分配；2.在栈上-函数执行时，函数内部局部变量的存储单元在栈上创建；3.在堆上面-动态内存分配-程序运行时申请  new/delete或者malloc/free。

4.1 字符串 ：puts输出，gets输入，strcat连接，strcpy复制，strlen字符串长度
	   auto 转双精度浮点，atoi转整型，atol转长整型。(可能考到数值转字符串  或者字符串转数值)
4.6 strcpy和memcpy：复制内容不同-前者只能复制字符串，后者可以复制任何；复制方式不同-前者不用指定长度，后者第三个决定复制多少；用途不同。

5.1 %f %lf %d 输出执行类型相同输出  前两个8位  <<n相当于乘2n  >>n相当于除2n
5.3 位操作 &和|   一个字节(byte)有8位，1MB = 1024*1024B = 1048576 * 8字节  ；1MB = 1024KB；1KB = 1024B；1B = 8字节。
5.7 四种运算符转换：const_cast:帮助掉欧阳那些应该使用却没有使用const关键字的函数；
		dynamic_cast:有助于判断运行时所指向对象的确切类型；
		reinterpret_cast:讲一个指针类型转换成其他类型指针；
		static_cast:能够在相关的对象和指针类型间进行类型转换。
5.12 无符号和有符号类型一起存在时，自动转换成无符号。
5.14 volatile：定义为volatile的变量说明其可能会被意想不到的改变，因此编译器就不会去假设这个变量的值。

6.1面向对象：按照人们认识客观世界的系统思维方式，采用基于对象的概念建立模型，模拟客观世界分析、设计、实现软件的办法。
	类(具有相似的内部状态和运动规律的实体集合 -----抽象、继承、封装、重载、多态)-对象(现实世界中各种各样的实体，类的实例)-消息(对象之间相互联系和相互作用的方式)
6.4 class和struct区别：C语言的struct和c++中的class(c一种复杂数据类型定义，中只能定义成员变量，不能定义函数)；c++中的struct和class(默认访问方式，public和private；模板可以使用class和typename，不能使用struct)；
6.5 如果构造函数带参数，定义对象时代(),否则不带(). 类的私有成员函数 不能使用对象调用。变量先定义先初始化。
6.8 static被看成全局变量，需要在类外初始化。 使用其可以隐藏信息，因为其是private，不会存在全局名称冲突。
6.9 初始化列表和赋值，对于const和reference类型成员变量，只能进行初始化。
6.14 空类默认会有  构造函数、析构函数、复制构造函数、赋值函数和取值运算。构造函数可以被重载，析构(只能有一个)不能。
重载和重写(覆盖)区别：重载可以带virtual，也可以不带，重写一定要带virtual；重载参数等可以不同，重写参数和类型一定相同
6.18 explicit构造函数 防止隐式转换。
6.20 虚析构函数，保证子类能够调用相应的析构函数，释放资源。
6.22 复制构造函数：一个对象以值传入函数体，一个对象以值传递方式从函数返回，一个对象需要通过另外一个对象进行初始化。
6.31 临时对象-真正临时对象看不到，会影响程序执行效率，通常想避免临时对象-参数按值传递-返回值按值传递
6.32 重载函数用来描述同名函数具有相同或者相似的功能，但数据类型和参数不同。函数名经过c++编译器处理后包含原函数名、函数参数数量和返回类型信息，而c语言不会对函数名处理。
6.34 重载是指子类改写父类的方法，覆写是指同一个函数的不同版本之间参数不同。
	重载：方法名相同；参数列表不相同，不是顺序；返回累心够可以不同；
	覆写：派生类重写基类的虚函数，所有都相同，且基类声明成虚函数和抽象方法。

7.1 c++类继承三种关系：public：子类可以代替父类完成父类接口所声明的行为。
		     protected：将父类的public修改成protected，可以执行父类中的public和procted。完成父类中部分功能。
		     private：将父类所有转成private，子类的子类就不能够使用父类的public和procted。
7.5 私有继承和基类时(以。。。实现)不是“is a”关系，不是子类的对象和基类的对象之间什么概念关系，私有在设计中没有什么意义，在实现中才有意义。
私有继承和组合： 都表示“有一个”关系。私有继承派生类能访问基类的proctected成员，并且能够重写基类的虚函数。组合不能用这些功能。
7.6 多态：多态-封装-继承是面向对象思想三大特征，定义：统一操作作用于不同对象，可以有不同解释和不同的执行结果。
	1. 编译时的多态-重载实现    非虚函数的成员系统在编译时，根据传递的参数、返回类型等决定实现何种操作。
	2. 运行时多态-虚函数进行实现   指当系统运行时，才根据实际其能够看决定实现何种操作。
7.7 虚函数通过虚函数表实现-如果一个类含有虚函数，则系统会为这个类分配一个指针成员指向一张虚函数表，表中每一项指向一个虚函数地址，实现上就是一个函数指针的数组。
7.8 构造函数中，虚函数机智不会发生作用。
7.12 多重继承：满足一些事物拥有两个或两个以上事物的属性。 对象可以调用多个基类中的接口； 若派生类所继承的多个基类有相同的基类，而派生类调用祖先类接口，就会出现二义性。  消除二义性可以将改成虚继承。
7.15 多重继承和虚拟继承：多重继承类对象的构造顺序和其继承列表中基类的排列顺序一致。
	1. 任何细腻基类的构造函数按照他们被继承的顺序构造。
	2.任何非虚拟基类的构造函数按照他们被构造的顺序构造。
	3.任何成员对象的构造按照他们生命的顺序调用。
	4.类自身的构造函数。
7.16 抽象基类和纯虚函数：纯虚函数在基类中没有定义，必须在子类中加以实现，1.方便使用多态。2.很多情况，基类生成对象不合理。   抽象基类不能被实例化，它定义的纯虚函数相当于借口，能吧派生类的共同行为提取出来。
7.17 虚函数和纯虚函数区别：
	1.类中如果声明的虚函数，就算是空实现，他就是为了这个函数在子类中能可以被覆盖。纯虚函数只是一个借口，只是函数的声明。
	2.虚函数在子类可以不重载，纯虚函数必需在子类去实现。
	3.虚函数继承接口的同时也继承的父类的实现，纯虚函数就是接口，实现必需在子类中。
	4.带纯虚函数类交虚基类，这种类不能直接生成对象，也叫抽象类，只有被继承并重写其虚函数才能够使用。

8.22队列和栈的区别：队列用链表和数组实现(fronthe rear队列首尾)
	1.操作名称不同，入队和出队；入栈和出栈。
	2.操作方式不同，队尾入，队头出，两边都可以操作；栈进出都是在栈顶。
	3.操作方式不同，队列(FIFO);栈(LIFO)
8.25 栈实现队列和队列实现栈 ----相互都需要两个   ：栈实现队列(栈s1入栈,然后是s1出栈将数据进栈s2,然后s2出栈实现先进先出)。队列实现栈(队列q1,进数据，然后出队列进入q2，剩最后一个输出，;将s2出队进入s1,剩最后一个输出，反复进行)
8.27 二叉树 前序(根左右)  中序(左根右)  后序(左右跟)  用递归和非递归实现遍历(主要用指针 遍历)      判定二叉树是否为排序二叉树，中序遍历即可

9.1 插入排序：一个数列，以第一个为基准，然后取后面的和前面的进行比较 和交换
9.2希尔排序：以步长进行交换  直到步长为1
9.3冒泡排序：双层循环，两两比较交换，设置一个标志
9.4 快速排序：以第一个为基准，从后往前找比他小的，然后从前往后找比他大的 ，一遍结束后分割成两部分。
9.5选择排序： 初始化元素最小元素为索引，以此索引，遇到最小的交换最小索引，将最小索引与首元素交换，依次初始化第二个待排序。
9.6堆排序：指针 最小最大堆
9.7归并排序：两两归并
9.10 基数排序(桶排序)：申请空间，建立不同大小的











10.1 泛化编程：编写完全一般化并可重复使用的算法，其效率与针对某特定数据类型而设计的算法相同。
例如：template<class T> 
          T max(T a,T b){ return a>b?a:b;}//class 代表类型  可以使用typename替换
10.2 函数模板和类模板：函数模板是一种抽象的函数定义，代表一类同构函数。 类模板是一种更高层次的抽象类定义，用于使用相同代码创建不同的类模板的定义和函数模板的定义类似，只是吧函数模板中的函数定义部分换作类说明。并对成员函数定义。
	函数模板实例化是由编译程序在处理函数调用时自动完成的，类模板的实例化必须由程序员在程序中显示指定。
10.3模板缺点：不当使用导致代码膨胀，严重影响效率。 c++中与模板中参数无关的代码分离出来。
10.5 模板的特化：分成函数模板特化和类模板特化(类模板内需要对某些类型进行特别处理时，使用特化)。

11.1标准模板：迭代器在容器和算法之间充当粘合剂-其可以使任何算法都可以和任何容器进行交互运作。  STL(标准模板库)包括：容器(****)、算法(algorithms***)、迭代器(类似于指针)组件。-高效的c++库，是最新c++标准可中的一个子集。
	顺序容器：vector string deque(双端队列) list
	关联容器：set multiset map multimap
	适配容器：stack queue(队列) priorit_queue
11.2  vector：支持随机访问，内部动态数组实现， insert  push_back  capacity  size  erase(删除后，元素会自动向前移动)
11.5 文件操作   ： #include<ifstream>  ifstream in("") ; while(!in.eof()){判断不为空   in>>temp;data.push_back(temp);}      输出文件   ofstream out("") for(int i = 0;i<data.size();i++){out << data[i]}
11.6 vector 和list区别：vector类似数组，一段连续内存空间，起始地址不变，迭代器支持+ += <。list数据结构双向链表实现，内存空间不连续，只能通过指针进行数据访问,迭代器（iterator）不支持+ += <。
		list执行erase后释放链表的节点内存，但可以通过erase返回值获取原链表的下一个元素。 vector 执行erase元素自动前移。
11.9 vector和deque：deque比vector多了push_front和pop_front; deque不存在capacity(获取容量)和reserve(设置容量)；
11.10 stack 、queue set(无重复数据) map(每一个元素都会有一个键值，且键值唯一)   STL底层是红黑树实现的(map底层是红黑树实现   根节点黑色，父节点是红则子节点都是黑 ，所有叶子结点都是空节点，且为黑)
11.14 map和hashmap：map 是红黑树，maphash是哈希表，前者按照键值自动排序，后者平均时间复杂度接近常数。
11.18 auto_ptr(智能指针)：促使动态内存和异常之前进行平滑交互。其保证当异常抛出时，分配的对象能自动销毁，内存能被自动释放。



